<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Axis & Allies: WWII 1942</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.3.1/umd/react.production.min.js" defer onerror="this.onerror=null;this.src='https://unpkg.com/react@18.3.3.1.umd/react.min.js'"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.3.1/dist/umd/react-dom.production.min.js" defer onerror="this.onerror=null;this.src='https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js'"></script>
  <script src="https://cdn.jsdelivr.net/npm/zustand@4.5.5/dist/zustand.umd.min.js" defer onerror="this.onerror=null;this.src='https://unpkg.com/zustand@4.5.5/dist/zustand.umd.min.js'"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js'"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.14/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" onerror="this.onerror=null;this.href='https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css'">
  <style>
    #map { height: 80vh; min-height: 400px; }
    @media (max-width: 640px) { #map { height: 60vh; } }
    .modal { backdrop-filter: blur(5px); }
    .territory-germany, .territory-japan { color: #dc2626; font-weight: 700; fill: #dc2626; fill-opacity: 0.3; }
    .territory-united_kingdom, .territory-soviet_union, .territory-united_states { color: #2563eb; font-weight: 700; fill: #2563eb; fill-opacity: 0.3; }
    .territory-neutral { color: #6b7280; font-weight: 700; fill: #6b7280; fill-opacity: 0.3; }
    .unit-icon { width: 20px; height: 20px; }
    .animate-move { animation: moveUnit .5s ease; }
    .selected { animation: glow 1s ease-in-out infinite alternate; }
    .tutorial-overlay { background: rgba(0,0,0,0.7); color: white; padding: 1rem; border-radius: 0.5rem; }
    .modal-button { min-width: 120px; padding: 0.75rem 1.5rem; font-size: 1rem; }
    .loading { display: flex; justify-content: center; align-items: center; height: 100vh; background: #f3f4f6; }
    .spinner { border: 4px solid #2563eb; border-top: 4px solid transparent; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
    .animate-modal { animation: fadeIn .3s ease; }
    .animate-unit-place { animation: scaleUp .3s ease; }
    @keyframes moveUnit { 0% { transform: translateY(10px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes glow { 0% { box-shadow: 0 0 5px rgba(59,130,246,0.5); } 100% { box-shadow: 0 0 15px rgba(59,130,246,0.8); } }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes fadeIn { 0% { opacity: 0; transform: translateY(-10px); } 100% { opacity: 1; transform: translateY(0); } }
    @keyframes scaleUp { 0% { transform: scale(0.8); } 100% { transform: scale(1); } }
    .theme-dark { background-color: #1f2937; color: #f3f4f6; }
    .theme-dark .bg-white { background-color: #374151; }
    .theme-dark .border-gray-100 { border-color: #4b5563; }
    .theme-dark .loading { background: #1f2937; }
  </style>
</head>
<body class="bg-gray-50 font-sans antialiased transition-colors duration-300">
  <div id="app-root"></div>
  <script type="text/javascript">
    // Ensure balanced parentheses and robust error handling.
    const GEOJSON = {
      type: "FeatureCollection",
      features: [
        { type: "Feature", properties: { name: "Germany", owner: "Germany" }, geometry: { type: "Polygon", coordinates: [[[5,47],[15,47],[15,55],[5,55],[5,47]]] } },
        { type: "Feature", properties: { name: "Russia", owner: "Soviet_Union" }, geometry: { type: "Polygon", coordinates: [[[30,50],[60,50],[60,70],[30,70],[30,50]]] } },
        { type: "Feature", properties: { name: "United Kingdom", owner: "United_Kingdom" }, geometry: { type: "Polygon", coordinates: [[[-10,50],[0,50],[0,60],[-10,60],[-10,50]]] } },
        { type: "Feature", properties: { name: "Japan", owner: "Japan" }, geometry: { type: "Polygon", coordinates: [[[130,30],[140,30],[140,40],[130,40],[130,30]]] } },
        { type: "Feature", properties: { name: "United States", owner: "United_States" }, geometry: { type: "Polygon", coordinates: [[[-125,30],[-65,30],[-65,50],[-125,50],[-125,30]]] } },
        { type: "Feature", properties: { name: "Sea Zone 6", owner: "Neutral" }, geometry: { type: "Polygon", coordinates: [[[0,40],[20,40],[20,60],[0,60],[0,40]]] } },
        { type: "Feature", properties: { name: "Sea Zone 17", owner: "Neutral" }, geometry: { type: "Polygon", coordinates: [[[140,25],[160,25],[160,45],[140,45],[140,25]]] } }
      ]
    };
    function checkDependencies() {
      try {
        console.log("Checking dependencies...");
        if (!window.React || !React.createElement) throw new Error("React not loaded");
        if (!window.ReactDOM || !ReactDOM.render) throw new Error("ReactDOM not loaded");
        if (!window.zustand || !zustand.create) throw new Error("Zustand not loaded");
        if (!window.L || !L.map) throw new Error("Leaflet not loaded");
        console.log("Dependencies OK");
        return true;
      } catch (e) {
        throw new Error(`Dependency check failed: ${e.message}`);
      }
    }
    function waitForDependencies(callback, timeout = 10000, interval = 100) {
      console.log("Starting dependency wait...");
      const start = Date.now();
      const check = () => {
        try {
          if (checkDependencies()) {
            console.log("Executing callback...");
            callback();
            return;
          }
        } catch (e) {
          console.warn("Waiting for dependencies:", e.message);
        }
        if (Date.now() - start > timeout) {
          console.error("Dependency timeout");
          ReactDOM.render(
            React.createElement("div", { className: "text-red-600 p-4" }, "Failed to load game. Check network and refresh."),
            document.getElementById("app-root")
          );
          return;
        }
        setTimeout(check, interval);
      };
      check();
    }
    waitForDependencies(function() {
      try {
        console.log("Initializing app...");
        const { create } = window.zustand;
        const UNITS = {
          infantry: { cost: 3, attack: 1, defense: 2, move: 1, type: "land", icon: "üë®‚ÄçüöÄ" },
          artillery: { cost: 4, attack: 2, defense: 2, move: 1, type: "land", boostsInfantry: true, icon: "üéØ" },
          tank: { cost: 6, attack: 3, defense: 3, move: 2, type: "land", icon: "üöú" },
          fighter: { cost: 10, attack: 3, defense: 4, move: 4, type: "air", icon: "‚úàÔ∏è" },
          bomber: { cost: 12, attack: 4, defense: 1, move: 6, type: "air", icon: "üí£" },
          aaa: { cost: 5, attack: 0, defense: 1, move: 1, type: "land", antiAir: true, icon: "üî´" },
          submarine: { cost: 6, attack: 2, defense: 1, move: 2, type: "sea", surpriseStrike: true, icon: "üö§" },
          destroyer: { cost: 8, attack: 2, defense: 2, move: 2, type: "sea", icon: "‚õµ" },
          cruiser: { cost: 12, attack: 3, defense: 3, move: 2, type: "sea", icon: "üö¢" },
          battleship: { cost: 20, attack: 4, defense: 4, move: 2, type: "sea", icon: "‚öì" },
          carrier: { cost: 16, attack: 1, defense: 2, move: 2, type: "sea", carries: 2, icon: "üõ´" },
          transport: { cost: 7, attack: 0, defense: 1, move: 2, type: "sea", carries: 2, icon: "‚õ¥Ô∏è" }
        };
        const NATION_SYMBOLS = { Germany: "üá©üá™", Japan: "üáØüáµ", United_Kingdom: "üá¨üáß", Soviet_Union: "üá∑üá∫", United_States: "üá∫üá∏", Neutral: "‚ö™" };
        const TERRITORIES = [
          { name: "Germany", coords: [51.1657, 10.4515], owner: "Germany", ipcs: 10, units: { infantry: 6, tank: 3, fighter: 2, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
          { name: "Southern Europe", coords: [42.5, 12.5], owner: "Germany", ipcs: 2, units: { infantry: 2, artillery: 1 }, factory: true },
          { name: "Western Europe", coords: [48.5, 2.5], owner: "Germany", ipcs: 6, units: { infantry: 3, tank: 1, aaa: 1 }, factory: true },
          { name: "Norway", coords: [64, 10], owner: "Germany", ipcs: 2, units: { infantry: 2 } },
          { name: "Finland", coords: [65, 25], owner: "Germany", ipcs: 1, units: { infantry: 1 } },
          { name: "Eastern Europe", coords: [50, 25], owner: "Germany", ipcs: 3, units: { infantry: 3, tank: 1 } },
          { name: "Ukraine", coords: [48, 30], owner: "Germany", ipcs: 3, units: { infantry: 2, artillery: 1 } },
          { name: "Caucasus", coords: [43, 45], owner: "Soviet_Union", ipcs: 3, units: { infantry: 2 }, factory: true },
          { name: "Russia", coords: [55, 37], owner: "Soviet_Union", ipcs: 10, units: { infantry: 6, tank: 2, fighter: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
          { name: "Archangel", coords: [64, 40], owner: "Soviet_Union", ipcs: 2, units: { infantry: 1 } },
          { name: "Karelia S.S.R.", coords: [62, 30], owner: "Soviet_Union", ipcs: 2, units: { infantry: 2, artillery: 1 }, factory: true },
          { name: "United Kingdom", coords: [55.3781, -3.436], owner: "United_Kingdom", ipcs: 8, units: { infantry: 2, fighter: 2, bomber: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
          { name: "Gibraltar", coords: [36, -5], owner: "United_Kingdom", ipcs: 0, units: { infantry: 1 } },
          { name: "Egypt", coords: [30, 31], owner: "United_Kingdom", ipcs: 2, units: { infantry: 2, tank: 1 }, victoryCity: true },
          { name: "Union of South Africa", coords: [-30, 25], owner: "United_Kingdom", ipcs: 2, units: { infantry: 1 }, factory: true },
          { name: "French West Africa", coords: [15, -5], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
          { name: "French Equatorial Africa", coords: [0, 15], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
          { name: "Italian East Africa", coords: [5, 40], owner: "Germany", ipcs: 1, units: { infantry: 1 } },
          { name: "Libya", coords: [25, 20], owner: "Germany", ipcs: 1, units: { infantry: 1 } },
          { name: "Morocco", coords: [32, -5], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
          { name: "Japan", coords: [36.2048, 138.2529], owner: "Japan", ipcs: 8, units: { infantry: 6, fighter: 2, bomber: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
          { name: "Manchuria", coords: [45, 125], owner: "Japan", ipcs: 3, units: { infantry: 2, artillery: 1 } },
          { name: "Kiangsu", coords: [32, 120], owner: "Japan", ipcs: 3, units: { infantry: 2, fighter: 1 } },
          { name: "India", coords: [20, 77], owner: "United_Kingdom", ipcs: 3, units: { infantry: 3, artillery: 1, aaa: 1 }, factory: true, victoryCity: true },
          { name: "Burma", coords: [22, 95], owner: "United_Kingdom", ipcs: 1, units: { infantry: 1 } },
          { name: "French Indo-China", coords: [15, 105], owner: "Japan", ipcs: 2, units: { infantry: 1 } },
          { name: "China", coords: [35, 105], owner: "United_States", ipcs: 2, units: { infantry: 4 } },
          { name: "Szechwan", coords: [30, 100], owner: "United_States", ipcs: 2, units: { infantry: 1 } },
          { name: "Yunnan", coords: [25, 100], owner: "United_States", ipcs: 1, units: { infantry: 1 } },
          { name: "Kwangtung", coords: [22, 115], owner: "United_Kingdom", ipcs: 3, units: { infantry: 1 }, victoryCity: true },
          { name: "Philippines", coords: [15, 120], owner: "United_States", ipcs: 2, units: { infantry: 2 }, victoryCity: true },
          { name: "Hawaii", coords: [20, -155], owner: "United_States", ipcs: 1, units: { infantry: 1, fighter: 1 } },
          { name: "Australia", coords: [-25, 135], owner: "United_Kingdom", ipcs: 3, units: { infantry: 2, artillery: 1 }, factory: true, victoryCity: true },
          { name: "New Zealand", coords: [-40, 175], owner: "United_Kingdom", ipcs: 1, units: { infantry: 1 } },
          { name: "Caroline Islands", coords: [5, 155], owner: "Japan", ipcs: 0, units: { infantry: 1 } },
          { name: "Solomon Islands", coords: [-10, 160], owner: "Japan", ipcs: 0, units: { infantry: 1 } },
          { name: "New Guinea", coords: [-5, 145], owner: "Japan", ipcs: 1, units: { infantry: 1 } },
          { name: "Dutch New Guinea", coords: [-5, 135], owner: "Neutral", ipcs: 1, units: { infantry: 1 } },
          { name: "United States", coords: [37.0902, -95.7129], owner: "United_States", ipcs: 17, units: { infantry: 3, fighter: 2, bomber: 1, aaa: 1 }, isCapital: true, factory: true, victoryCity: true },
          { name: "Alaska", coords: [65, -150], owner: "United_States", ipcs: 1, units: { infantry: 1 } },
          { name: "Central America", coords: [10, -85], owner: "United_States", ipcs: 1, units: { infantry: 1 } },
          { name: "Sea Zone 6", coords: [55, -10], owner: "Neutral", ipcs: 0, units: { destroyer: 1, transport: 1 }, sea: true },
          { name: "Sea Zone 17", coords: [35, 145], owner: "Neutral", ipcs: 0, units: { carrier: 1, fighter: 2, destroyer: 1 }, sea: true }
        ];
        const useGameStore = create((set, get) => ({
          mode: "hotseat",
          currentNation: "Germany",
          turnOrder: ["Germany", "Soviet_Union", "Japan", "United_States", "United_Kingdom"],
          currentPhase: "Research & Development",
          ipcs: { Germany: 30, Soviet_Union: 28, Japan: 26, United_States: 42, United_Kingdom: 28 },
          purchasedUnits: {},
          combat: [],
          selectedTerritory: null,
          territories: TERRITORIES,
          markers: {},
          sessionId: "local",
          players: { Germany: "human", Soviet_Union: "human", Japan: "human", United_States: "human", United_Kingdom: "human" },
          isDarkMode: false,
          tutorialStep: 1,
          lastAction: null,
          aiHint: null,
          chatMessages: [],
          analytics: { battles: 0, actions: 0 },
          isLoading: true,
          setMode: mode => set({ mode, players: mode === "computer" ? { Germany: "computer", Soviet_Union: "human", Japan: "computer", United_States: "human", United_Kingdom: "human" } : { Germany: "human", Soviet_Union: "human", Japan: "human", United_States: "human", United_Kingdom: "human" } }),
          setPhase: phase => set({ currentPhase: phase }),
          setNation: nation => set({ currentNation: nation }),
          selectTerritory: territory => set({ selectedTerritory: territory }),
          toggleDarkMode: () => set(state => ({ isDarkMode: !state.isDarkMode })),
          advanceTutorial: () => set(state => ({ tutorialStep: state.tutorialStep + 1 })),
          disableTutorial: () => set({ tutorialStep: 0 }),
          setLastAction: action => set(state => ({ lastAction: action, analytics: { ...state.analytics, actions: state.analytics.actions + 1 } })),
          undoLastAction: () => {
            const state = get();
            if (state.lastAction) {
              const { type, data } = state.lastAction;
              switch (type) {
                case "purchases":
                  state.ipcs[state.currentNation] += data.cost;
                  state.purchasedUnits[state.currentNation] = null;
                  break;
                case "combatMove":
                  state.territories.find(t => t.name === data.source).units = { ...data.units };
                  state.combat = state.combat.filter(c => c.defender.name !== data.target);
                  break;
                case "nonCombatMove":
                  state.territories.find(t => t.name === data.source).units = { ...data.units };
                  state.territories.find(t => t.name === data.target).units = data.targetUnits || {};
                  break;
              }
              set({ lastAction: null });
            }
          },
          setAIHint: hint => set({ aiHint: hint }),
          addChat: msg => set(state => ({ chatMessages: [...state.chatMessages, { sender: state.currentNation, text: msg, time: new Date().toLocaleTimeString() }] })),
          updateAnalytics: (key, value) => set(state => ({ analytics: { ...state.analytics, [key]: state.analytics[key] + value } })),
          setLoading: isLoading => set({ isLoading }),
          saveGame: () => {
            try {
              const state = get();
              localStorage.setItem(`a&a_${state.sessionId}`, JSON.stringify(state));
            } catch (e) {
              console.error("Failed to save game:", e.message);
            }
          },
          resetGame: () => set({
            mode: "hotseat",
            currentNation: "Germany",
            turnOrder: ["Germany", "Soviet_Union", "Japan", "United_States", "United_Kingdom"],
            currentPhase: "Research & Development",
            ipcs: { Germany: 30, Soviet_Union: 28, Japan: 26, United_States: 42, United_Kingdom: 28 },
            purchasedUnits: {},
            combat: [],
            selectedTerritory: null,
            territories: TERRITORIES,
            markers: {},
            sessionId: "local",
            players: { Germany: "human", Soviet_Union: "human", Japan: "human", United_States: "human", United_Kingdom: "human" },
            tutorialStep: 1,
            lastAction: null,
            aiHint: null,
            chatMessages: [],
            analytics: { battles: 0, actions: 0 },
            isLoading: false
          })
        }));
        const GameLogic = {
          calculatePurchaseCost: units => Object.entries(units).reduce((sum, [type, count]) => sum + (UNITS[type]?.cost || 0) * count, 0),
          parseUnitInput: (units, availableUnits) => {
            const result = {};
            for (const [type, count] of Object.entries(units)) {
              const num = parseInt(count);
              if (UNITS[type] && !isNaN(num) && num > 0 && availableUnits[type] >= num) result[type] = num;
            }
            return Object.keys(result).length > 0 ? result : null;
          },
          canMoveUnits: (territory, unitsToMove) => {
            for (const [type, count] of Object.entries(unitsToMove)) {
              if (!territory.units[type] || territory.units[type] < count) return false;
            }
            return true;
          },
          conductCombat: () => {
            const { combat, currentNation, updateAnalytics } = useGameStore.getState();
            combat.forEach(({ attacker, defender, units: attackingUnits }) => {
              let attackerPower = 0, defenderPower = 0, infantryBoosted = 0;
              for (const [type, count] of Object.entries(attackingUnits)) {
                if (type === "artillery" && infantryBoosted < count) infantryBoosted += count;
                attackerPower += count * (UNITS[type].attack || 0);
                if (UNITS[type].surpriseStrike && !defender.units.destroyer) attackerPower += count;
              }
              if (attackingUnits.infantry && infantryBoosted > 0) attackerPower += Math.min(attackingUnits.infantry, infantryBoosted);
              for (const [type, count] of Object.entries(defender.units)) {
                defenderPower += count * (UNITS[type].defense || 0);
              }
              if (defender.units.aaa && Object.keys(attackingUnits).some(type => UNITS[type].type === "air")) {
                const airUnits = Object.entries(attackingUnits).reduce((sum, [type, count]) => sum + (UNITS[type].type === "air" ? count : 0), 0);
                const aaaHits = Math.min(defender.units.aaa, Math.floor(Math.random() * airUnits));
                GameLogic.reduceUnits(attackingUnits, aaaHits);
              }
              const attackerHits = Math.floor(Math.random() * (attackerPower / 2 + 1));
              const defenderHits = Math.floor(Math.random() * (defenderPower / 2 + 1));
              GameLogic.reduceUnits(attackingUnits, defenderHits);
              GameLogic.reduceUnits(defender.units, attackerHits);
              const attackerRemaining = Object.values(attackingUnits).reduce((sum, count) => sum + count, 0);
              const defenderRemaining = Object.values(defender.units).reduce((sum, count) => sum + count, 0);
              if (defenderRemaining === 0 && attackerRemaining > 0) {
                defender.owner = currentNation;
                defender.units = { ...attackingUnits };
                if (defender.factory) defender.factoryDamage = 0;
                alert(`${currentNation} captures ${defender.name}!`);
              } else if (attackerRemaining === 0) {
                alert(`${currentNation}'s attack on ${defender.name} failed!`);
              } else {
                alert(`Combat in ${defender.name} ongoing.`);
              }
              updateAnalytics("battles", 1);
            });
            useGameStore.setState({ combat: [] });
            GameLogic.checkGameOver();
          },
          reduceUnits: (unitSet, hits) => {
            let remainingHits = hits;
            for (const type of Object.keys(UNITS)) {
              while (remainingHits > 0 && unitSet[type] > 0) {
                unitSet[type]--;
                remainingHits--;
              }
            }
          },
          checkGameOver: () => {
            const { territories, resetGame } = useGameStore.getState();
            const axisVictoryCities = territories.filter(t => t.victoryCity && (t.owner === "Germany" || t.owner === "Japan")).length;
            const alliesVictoryCities = territories.filter(t => t.victoryCity && (t.owner === "Soviet_Union" || t.owner === "United_Kingdom" || t.owner === "United_States")).length;
            const axisCapitals = territories.filter(t => t.isCapital && (t.owner === "Germany" || t.owner === "Japan")).length;
            const alliesCapitals = territories.filter(t => t.isCapital && (t.owner === "Soviet_Union" || t.owner === "United_Kingdom" || t.owner === "United_States")).length;
            if (axisCapitals === 0 || alliesVictoryCities >= 12) {
              alert("Allies win!");
              resetGame();
            } else if (alliesCapitals === 0 || axisVictoryCities >= 12) {
              alert("Axis win!");
              resetGame();
            }
          },
          suggestAIMove: () => {
            const { currentPhase, currentNation, ipcs, territories, purchasedUnits } = useGameStore.getState();
            let hint = "";
            switch (currentPhase) {
              case "Research & Development":
                hint = ipcs[currentNation] >= 5 ? "Consider spending 5 IPCs to attempt research." : "Skip research to save IPCs.";
                break;
              case "Purchase Units":
                hint = `Purchase units within ${ipcs[currentNation]} IPCs, e.g., ${Math.floor(ipcs[currentNation] / 3)} infantry or ${Math.floor(ipcs[currentNation] / 6)} tanks.`;
                break;
              case "Combat Move":
                const aiTerritories = territories.filter(t => t.owner === currentNation && Object.values(t.units).reduce((sum, c) => sum + c, 0) > 2);
                const target = territories.find(t => t.owner !== currentNation && t.ipcs > 1 && Object.values(t.units).reduce((sum, c) => sum + c, 0) <= 3);
                hint = aiTerritories.length && target ? `Attack ${target.name} from ${aiTerritories[0].name} with 2 infantry, 1 tank.` : "No strong attack targets available.";
                break;
              case "Non-Combat Move":
                hint = "Move units to reinforce key territories like capitals or victory cities.";
                break;
              case "Mobilize New Units":
                hint = purchasedUnits[currentNation] ? `Place units in a factory, e.g., ${territories.find(t => t.factory && t.owner === currentNation)?.name}.` : "No units to mobilize.";
                break;
              case "Collect Income":
                hint = "Collect income automatically after this phase.";
                break;
            }
            useGameStore.getState().setAIHint(hint);
          },
          runAITurn: () => {
            const { currentPhase, currentNation, ipcs, territories, purchasedUnits, selectTerritory, setPhase, combat, updateAnalytics } = useGameStore.getState();
            GameLogic.suggestAIMove();
            switch (currentPhase) {
              case "Research & Development":
                if (ipcs[currentNation] >= 5 && Math.random() < 0.3) {
                  useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - 5 } }));
                  updateAnalytics("battles", 5);
                }
                setPhase("Purchase Units");
                break;
              case "Purchase Units":
                const purchases = { infantry: Math.floor(ipcs[currentNation] * 0.7 / 3), tank: Math.floor(ipcs[currentNation] * 0.3 / 6) };
                const cost = purchases.infantry * 3 + purchases.tank * 6;
                useGameStore.setState(state => ({
                  purchasedUnits: { ...state.purchasedUnits, [currentNation]: purchases },
                  ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - cost }
                }));
                useGameStore.getState().setLastAction({ type: "purchases", data: { cost, purchases } });
                updateAnalytics("battles", cost);
                setPhase("Combat Move");
                break;
              case "Combat Move":
                const aiTerritories = territories.filter(t => t.owner === currentNation && Object.values(t.units).reduce((sum, c) => sum + c, 0) > 2);
                const target = territories.find(t => t.owner !== currentNation && t.ipcs > 1 && Object.values(t.units).reduce((sum, c) => sum + c, 0) <= 3);
                if (aiTerritories.length && target) {
                  selectTerritory(aiTerritories[0]);
                  const unitsToMove = { infantry: Math.min(2, aiTerritories[0].units.infantry || 0), tank: Math.min(1, aiTerritories[0].units.tank || 0) };
                  useGameStore.setState(state => ({ combat: [...state.combat, { attacker: aiTerritories[0], defender: target, units: unitsToMove }] }));
                  useGameStore.getState().setLastAction({ type: "combatMove", data: { source: aiTerritories[0].name, target: target.name, units: unitsToMove } });
                  for (const [type, count] of Object.entries(unitsToMove)) {
                    aiTerritories[0].units[type] -= count;
                  }
                }
                setPhase("Conduct Combat");
                break;
              case "Conduct Combat":
                if (combat.length > 0) GameLogic.conductCombat();
                else setPhase("Non-Combat Move");
                break;
              case "Non-Combat Move":
                const source = territories.find(t => t.owner === currentNation && t.units.infantry > 2);
                const dest = territories.find(t => t.owner === currentNation && t !== source && t.ipcs > 1);
                if (source && dest) {
                  const unitsMoved = { infantry: 1 };
                  dest.units.infantry = (dest.units.infantry || 0) + 1;
                  source.units.infantry -= 1;
                  useGameStore.getState().setLastAction({ type: "nonCombatMove", data: { source: source.name, target: dest.name, units: unitsMoved, targetUnits: dest.units } });
                }
                setPhase("Mobilize New Units");
                break;
              case "Mobilize New Units":
                const factory = territories.find(t => t.owner === currentNation && t.factory);
                if (factory && purchasedUnits[currentNation]) {
                  selectTerritory(factory);
                  const factoryLimit = factory.ipcs - (factory.factoryDamage || 0);
                  const purchasedCount = Object.values(purchasedUnits[currentNation]).reduce((sum, count) => sum + count, 0);
                  if (purchasedCount <= factoryLimit) {
                    factory.units = { ...factory.units, ...purchasedUnits[currentNation] };
                    useGameStore.setState(state => ({ purchasedUnits: { ...state.purchasedUnits, [currentNation]: null } }));
                  }
                }
                setPhase("Collect Income");
                break;
              case "Collect Income":
                const income = territories.filter(t => t.owner === currentNation && !t.sea).reduce((sum, t) => sum + t.ipcs, 0);
                useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] + income } }));
                GameLogic.nextPhase();
                break;
            }
          },
          nextPhase: () => {
            const { currentPhase, currentNation, turnOrder, setPhase, setNation, players, saveGame } = useGameStore.getState();
            const phases = ["Research & Development", "Purchase Units", "Combat Move", "Conduct Combat", "Non-Combat Move", "Mobilize New Units", "Collect Income"];
            const currentIndex = phases.indexOf(currentPhase);
            const nextPhaseIndex = (currentIndex + 1) % phases.length;
            setPhase(phases[nextPhaseIndex]);
            if (nextPhaseIndex === 0) {
              const nationIndex = turnOrder.indexOf(currentNation);
              const nextNation = turnOrder[(nationIndex + 1) % turnOrder.length];
              setNation(nextNation);
              useGameStore.setState({ selectedTerritory: null });
              if (players[nextNation] === "computer") GameLogic.runAITurn();
            }
            saveGame();
          }
        };
        const e = React.createElement;
        const ErrorBoundary = ({ children }) => {
          const [hasError, setHasError] = React.useState(false);
          React.useEffect(() => {
            const errorHandler = (error, info) => {
              console.error("ErrorBoundary caught:", error, info);
              setHasError(true);
            };
            window.addEventListener("error", errorHandler);
            return () => window.removeEventListener("error", errorHandler);
          }, []);
          if (hasError) {
            return e("div", { className: "text-red-600 p-4 text-center" }, "Something went wrong. Please refresh the page.");
          }
          return children;
        };
        const Modal = React.memo(({ isOpen, onClose, title, children, tutorialStep, tutorialText }) => {
          if (!isOpen) return null;
          return e(
            "div",
            { className: "fixed inset-0 bg-black bg-opacity-50 modal flex items-center justify-center z-50 animate-modal", role: "dialog", "aria-labelledby": "modal-title" },
            e(
              "div",
              { className: "bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full sm:max-w-lg" },
              e("h2", { id: "modal-title", className: "text-xl font-bold mb-4 dark:text-white" }, title),
              tutorialStep && e("div", { className: "tutorial-overlay mb-4" }, "Step ", tutorialStep, ": ", tutorialText),
              children,
              e("div", { className: "flex justify-end gap-2 mt-4" },
                e("button", { onClick: onClose, className: "modal-button bg-gray-500 text-white rounded hover:bg-gray-600", "aria-label": "Close modal" }, "Close")
              )
            )
          );
        });
        const GameMap = React.memo(() => {
          const [map, setMap] = React.useState(null);
          const { territories, selectedTerritory, selectTerritory } = useGameStore();
          React.useEffect(() => {
            const initMap = () => {
              if (!document.getElementById("map")) {
                setTimeout(initMap, 100);
                return;
              }
              const leafletMap = L.map("map", { zoomControl: true, minZoom: 2, maxZoom: 6, doubleClickZoom: true }).setView([20, 0], 2);
              L.tileLayer("http://{s}.tile.stamen.com/watercolor/{z}/{x}/{y}.jpg", {
                attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'
              }).addTo(leafletMap);
              L.tileLayer("http://{s}.tile.stamen.com/toner-hybrid/{z}/{x}/{y}.png", { opacity: 0.3 }).addTo(leafletMap);
              leafletMap.setMaxBounds([[-60, -180], [80, 180]]);
              L.geoJSON(GEOJSON, {
                style: feature => ({
                  fillColor: feature.properties.owner === "Germany" || feature.properties.owner === "Japan" ? "#dc2626" : feature.properties.owner === "Neutral" ? "#6b7280" : "#2563eb",
                  fillOpacity: feature.properties.name.startsWith("Sea Zone") ? 0.1 : 0.3,
                  weight: 2,
                  color: "#ffffff"
                }),
                onEachFeature: (feature, layer) => {
                  layer.on("click", () => selectTerritory(territories.find(t => t.name === feature.properties.name)));
                  if (selectedTerritory && feature.properties.name === selectedTerritory.name) {
                    layer.bindTooltip("Selected", { permanent: false }).openTooltip();
                  }
                }
              }).addTo(leafletMap);
              setMap(leafletMap);
            };
            initMap();
            return () => { if (map) map.remove(); };
          }, []);
          const markers = React.useMemo(() => {
            if (!map) return {};
            const layerGroup = L.layerGroup().addTo(map);
            const newMarkers = territories.reduce((acc, territory) => {
              const markerClass = `territory-${territory.owner.toLowerCase()} ${selectedTerritory && selectedTerritory.name === territory.name ? "selected" : ""}`;
              const symbol = NATION_SYMBOLS[territory.owner] || "‚ö™";
              const unitSummary = Object.entries(territory.units).filter(([_, count]) => count > 0).map(([type, count]) => `${type}: ${count}`).join("<br>");
              const marker = L.marker(territory.coords, {
                icon: L.divIcon({ className: markerClass, html: `<span>${symbol} ${territory.name}${territory.victoryCity ? " üèõÔ∏è" : ""}${territory.factory ? " üè≠" : ""}</span>` })
              }).bindTooltip(`<b>${territory.name}</b><br>IPCs: ${territory.ipcs}<br>${unitSummary || 'No units'}`, { direction: "top" });
              marker.on("click", () => selectTerritory(territory));
              marker.addTo(layerGroup);
              acc[territory.name] = marker;
              return acc;
            }, {});
            return { markers: newMarkers, layerGroup };
          }, [map, territories, selectedTerritory, selectTerritory]);
          React.useEffect(() => {
            useGameStore.setState({ markers: markers.markers });
            return () => markers.layerGroup.clearLayers();
          }, [markers]);
          return e("div", { id: "map", className: "rounded-lg shadow-lg border border-gray-200" });
        });
        const GamePanel = React.memo(() => {
          const { mode, currentNation, ipcs, currentPhase, selectedTerritory, territories, setMode, setPhase, saveGame, resetGame, tutorialStep, advanceTutorial, disableTutorial, lastAction, undoLastAction, aiHint, addChat } = useGameStore();
          const [modal, setModal] = React.useState({ isOpen: false, type: null, data: { target: null, units: {} } });
          const [error, setError] = React.useState("");
          const phaseBanner = e(
            "div",
            { className: "bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 p-3 rounded mb-4 text-sm" },
            `Current Phase: ${currentPhase}. `,
            currentPhase === "Research & Development" ? "Consider researching (5 IPCs)." :
            currentPhase === "Purchase Units" ? "Buy units with your IPCs." :
            currentPhase === "Combat Move" ? "Select a territory to attack." :
            currentPhase === "Conduct Combat" ? "Resolve planned battles." :
            currentPhase === "Non-Combat Move" ? "Move units to friendly territories." :
            currentPhase === "Mobilize New Units" ? "Place purchased units at factories." :
            "Collect income from your territories."
          );
          const handlePhaseAction = React.useCallback(() => {
            setError("");
            switch (currentPhase) {
              case "Research & Development":
                setModal({ isOpen: true, type: "research", data: {} });
                break;
              case "Purchase Units":
                setModal({ isOpen: true, type: "purchase", data: { units: {} } });
                break;
              case "Combat Move":
                if (selectedTerritory && selectedTerritory.owner === currentNation) {
                  setModal({ isOpen: true, type: "combatMove", data: {} });
                } else {
                  setError("Select a friendly territory!");
                }
                break;
              case "Conduct Combat":
                if (useGameStore.getState().combat.length > 0) GameLogic.conductCombat();
                else GameLogic.nextPhase();
                break;
              case "Non-Combat Move":
                if (selectedTerritory && selectedTerritory.owner === currentNation) {
                  setModal({ isOpen: true, type: "nonCombatMove", data: {} });
                } else {
                  setError("Select a friendly territory!");
                }
                break;
              case "Mobilize New Units":
                if (useGameStore.getState().purchasedUnits[currentNation] && selectedTerritory && selectedTerritory.factory) {
                  const factoryLimit = selectedTerritory.ipcs - (selectedTerritory.factoryDamage || 0);
                  const purchasedCount = Object.values(useGameStore.getState().purchasedUnits[currentNation]).reduce((sum, count) => sum + count, 0);
                  if (purchasedCount <= factoryLimit) {
                    selectedTerritory.units = { ...selectedTerritory.units, ...useGameStore.getState().purchasedUnits[currentNation] };
                    useGameStore.setState(state => ({ purchasedUnits: { ...state.purchasedUnits, [currentNation]: null } }));
                    alert(`Units mobilized in ${selectedTerritory.name}!`);
                    GameLogic.nextPhase();
                  } else {
                    setError(`Factory can only mobilize ${factoryLimit} units!`);
                  }
                } else {
                  setError("Select a territory with a factory!");
                }
                break;
              case "Collect Income":
                const income = useGameStore.getState().territories.filter(t => t.owner === currentNation && !t.sea).reduce((sum, t) => sum + t.ipcs, 0);
                useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] + income } }));
                alert(`${currentNation} collects ${income} IPCs!`);
                GameLogic.nextPhase();
                break;
            }
          }, [currentPhase, selectedTerritory, currentNation]);
          const handleModalSubmit = React.useCallback(data => {
            const { setLastAction } = useGameStore.getState();
            setError("");
            switch (modal.type) {
              case "research":
                if (ipcs[currentNation] >= 5 && data.confirm) {
                  useGameStore.setState(state => ({ ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - 5 } }));
                  useGameStore.getState().updateAnalytics("battles", 5);
                }
                advanceTutorial();
                GameLogic.nextPhase();
                break;
              case "purchase":
                const cost = GameLogic.calculatePurchaseCost(data.units);
                if (cost <= ipcs[currentNation] && cost > 0) {
                  useGameStore.setState(state => ({
                    purchasedUnits: { ...state.purchasedUnits, [currentNation]: data.units },
                    ipcs: { ...state.ipcs, [currentNation]: state.ipcs[currentNation] - cost }
                  }));
                  setLastAction({ type: "purchases", data: { cost, purchases: data.units } });
                  useGameStore.getState().updateAnalytics("battles", cost);
                  alert("Units purchased!");
                  advanceTutorial();
                  GameLogic.nextPhase();
                } else {
                  setError("Invalid purchase or insufficient IPCs!");
                }
                break;
              case "combatMove":
                const targetTerritory = territories.find(t => t.name === data.target);
                if (!targetTerritory || targetTerritory.owner === currentNation) {
                  setError("Invalid target!");
                  return;
                }
                if (!selectedTerritory.units || Object.values(selectedTerritory.units).reduce((sum, count) => sum + count, 0) <= 0) {
                  setError("No units to attack with!");
                  return;
                }
                const movingUnits = GameLogic.parseUnitInput(data.units, selectedTerritory.units);
                if (!movingUnits || !GameLogic.canMoveUnits(selectedTerritory, movingUnits)) {
                  setError("Invalid units or insufficient units to move!");
                  return;
                }
                useGameStore.setState(state => ({ combat: [...state.combat, { attacker: selectedTerritory, defender: targetTerritory, units: movingUnits }] }));
                setLastAction({ type: "combatMove", data: { source: selectedTerritory.name, target: targetTerritory.name, units: movingUnits } });
                for (const [type, count] of Object.entries(movingUnits)) {
                  selectedTerritory.units[type] -= count;
                }
                alert(`Combat move planned against ${targetTerritory.name}!`);
                advanceTutorial();
                GameLogic.nextPhase();
                break;
              case "nonCombatMove":
                const targetNonCombat = territories.find(t => t.name === data.target);
                if (!targetNonCombat || targetNonCombat.owner !== currentNation) {
                  setError("Invalid target!");
                  return;
                }
                if (selectedTerritory === targetNonCombat) {
                  setError("Cannot move to the same territory!");
                  return;
                }
                const movingNonCombatUnits = GameLogic.parseUnitInput(data.units, selectedTerritory.units);
                if (!movingNonCombatUnits || !GameLogic.canMoveUnits(selectedTerritory, movingNonCombatUnits)) {
                  setError("Invalid units or insufficient units to move!");
                  return;
                }
                const targetUnits = { ...targetNonCombat.units };
                for (const [type, count] of Object.entries(movingNonCombatUnits)) {
                  targetNonCombat.units[type] = (targetNonCombat.units[type] || 0) + count;
                  selectedTerritory.units[type] -= count;
                }
                setLastAction({ type: "nonCombatMove", data: { source: selectedTerritory.name, target: targetNonCombat.name, units: movingNonCombatUnits, targetUnits } });
                alert(`Units moved to ${targetNonCombat.name}!`);
                advanceTutorial();
                GameLogic.nextPhase();
                break;
            }
            setModal({ isOpen: false, type: null, data: { target: null, units: {} } });
          }, [modal, ipcs, currentNation, selectedTerritory, territories, advanceTutorial]);
          const tutorialText = {
            research: "Spend 5 IPCs to attempt research (no effect in this version). Click Confirm to proceed.",
            purchase: "Use sliders to select units within your IPC budget. Click Purchase to confirm.",
            combatMove: "Choose a target territory to attack and select units to move. Click Attack to confirm.",
            nonCombatMove: "Select a friendly territory to move units to. Click Move to confirm."
          };
          const modalContent = {
            research: e(
              "div",
              null,
              e("p", { className: "dark:text-gray-300" }, "Spend 5 IPCs to attempt research? (No tech in this version)"),
              e("button", { onClick: () => handleModalSubmit({ confirm: true }), className: "modal-button bg-blue-600 text-white rounded mt-4 hover:bg-blue-700" }, "Confirm")
            ),
            purchase: e(
              "div",
              null,
              e("p", { className: "dark:text-gray-300" }, "Available IPCs: ", ipcs[currentNation]),
              e("p", { className: "dark:text-gray-300 mt-2" }, "Total Cost: ", GameLogic.calculatePurchaseCost(modal.data.units)),
              error && e("p", { className: "text-red-600 text-sm mt-2" }, error),
              e(
                "div",
                { className: "space-y-2 mt-2" },
                Object.keys(UNITS).map(type =>
                  e(
                    "div",
                    { key: type, className: "flex items-center gap-2" },
                    e("label", { className: "text-sm dark:text-gray-300 w-20" }, type, ` (${UNITS[type].cost} IPCs)`),
                    e(
                      "input",
                      {
                        type: "range",
                        min: "0",
                        max: Math.floor(ipcs[currentNation] / UNITS[type].cost),
                        value: modal.data.units[type] || 0,
                        className: "w-full",
                        onChange: e => setModal(state => ({ ...state, data: { units: { ...state.data.units, [type]: parseInt(e.target.value) || 0 } } })),
                        "aria-label": `Select number of ${type} units`
                      }
                    ),
                    e("span", { className: "text-sm dark:text-gray-300 w-8" }, modal.data.units[type] || 0)
                  )
                )
              ),
              e("button", { onClick: () => handleModalSubmit(modal.data), className: "modal-button bg-blue-600 text-white rounded mt-4 hover:bg-blue-700" }, "Purchase")
            ),
            combatMove: e(
              "div",
              null,
              e("p", { className: "dark:text-gray-300" }, "Select target territory to attack:"),
              e(
                "select",
                {
                  className: "w-full border border-gray-300 dark:border-gray-600 rounded px-2 py-1 mt-2 text-sm dark:bg-gray-700 dark:text-white",
                  onChange: e => setModal(state => ({ ...state, data: { ...state.data, target: e.target.value } })),
                  "aria-label": "Select target territory"
                },
                e("option", { value: "" }, "Choose a territory"),
                territories.filter(t => t.owner !== currentNation && !t.sea).map(t => e("option", { key: t.name, value: t.name }, t.name))
              ),
              e("p", { className: "text-sm dark:text-gray-300 mt-2" }, "Select units to move:"),
              error && e("p", { className: "text-red-600 text-sm mt-2" }, error),
              e(
                "div",
                { className: "space-y-2 mt-2" },
                Object.keys(UNITS).map(type =>
                  e(
                    "div",
                    { key: type, className: "flex items-center gap-2" },
                    e("label", { className: "text-sm dark:text-gray-300 w-20" }, type),
                    e(
                      "input",
                      {
                        type: "range",
                        min: "0",
                        max: selectedTerritory?.units[type] || 0,
                        value: modal.data.units[type] || 0,
                        className: "w-full",
                        onChange: e => setModal(state => ({ ...state, data: { units: { ...state.data.units, [type]: parseInt(e.target.value) || 0 } } })),
                        "aria-label": `Select number of ${type} units`
                      }
                    ),
                    e("span", { className: "text-sm dark:text-gray-300 w-8" }, modal.data.units[type] || 0)
                  )
                )
              ),
              e("button", { onClick: () => handleModalSubmit(modal.data), className: "modal-button bg-blue-600 text-white rounded mt-4 hover:bg-blue-700" }, "Attack")
            ),
            nonCombatMove: e(
              "div",
              null,
              e("p", { className: "dark:text-gray-300" }, "Select friendly territory to move to:"),
              e(
                "select",
                {
                  className: "w-full border border-gray-300 dark:border-gray-600 rounded px-2 py-1 mt-2 text-sm dark:bg-gray-700 dark:text-white",
                  onChange: e => setModal(state => ({ ...state, data: { ...state.data, target: e.target.value } })),
                  "aria-label": "Select target territory"
                },
                e("option", { value: "" }, "Choose a territory"),
                territories.filter(t => t.owner === currentNation && t.name !== selectedTerritory?.name && !t.sea).map(t => e("option", { key: t.name, value: t.name }, t.name))
              ),
              e("p", { className: "text-sm dark:text-gray-300 mt-2" }, "Select units to move:"),
              error && e("p", { className: "text-red-600 text-sm mt-2" }, error),
              e(
                "div",
                { className: "space-y-2 mt-2" },
                Object.keys(UNITS).map(type =>
                  e(
                    "div",
                    { key: type, className: "flex items-center gap-2" },
                    e("label", { className: "text-sm dark:text-gray-300 w-20" }, type),
                    e(
                      "input",
                      {
                        type: "range",
                        min: "0",
                        max: selectedTerritory?.units[type] || 0,
                        value: modal.data.units[type] || 0,
                        className: "w-full",
                        onChange: e => setModal(state => ({ ...state, data: { units: { ...state.data.units, [type]: parseInt(e.target.value) || 0 } } })),
                        "aria-label": `Select number of ${type} units`
                      }
                    ),
                    e("span", { className: "text-sm dark:text-gray-300 w-8" }, modal.data.units[type] || 0)
                  )
                )
              ),
              e("button", { onClick: () => handleModalSubmit(modal.data), className: "modal-button bg-blue-600 text-white rounded mt-4 hover:bg-blue-700" }, "Move")
            )
          };
          React.useEffect(() => {
            const handleKeydown = e => {
              if (e.key === "Enter" && modal.isOpen) handleModalSubmit(modal.data);
              if (e.key === "Escape" && modal.isOpen) setModal({ isOpen: false, type: null, data: { target: null, units: {} } });
            };
            window.addEventListener("keydown", handleKeydown);
            return () => window.removeEventListener("keydown", handleKeydown);
          }, [modal, handleModalSubmit]);
          return e(
            "div",
            { className: "bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-100 dark:border-gray-700" },
            phaseBanner,
            error && e("p", { className: "text-red-600 text-sm mb-2" }, error),
            e("h3", { className: "text-lg font-bold mb-4 dark:text-white" }, "Game Controls"),
            e(
              "div",
              { className: "space-y-2 text-sm dark:text-gray-300" },
              e("p", null, e("span", { className: "font-medium" }, "Mode: "), mode === "hotseat" ? "Hot Seat" : mode === "computer" ? "Vs. Computer" : "Online"),
              e("p", null, e("span", { className: "font-medium" }, "Nation: "), currentNation),
              e("p", null, e("span", { className: "font-medium" }, "IPCs: "), ipcs[currentNation]),
              e("p", null, e("span", { className: "font-medium" }, "Phase: "), currentPhase),
              e("p", null, e("span", { className: "font-medium" }, "Territory: "), selectedTerritory ? selectedTerritory.name : "None"),
              selectedTerritory && e(
                "div",
                { className: "mt-3" },
                e("p", null, e("span", { className: "font-medium" }, "IPCs: "), selectedTerritory.ipcs),
                e("p", { className: "font-medium" }, "Units:"),
                e(
                  "ul",
                  { className: "list-disc pl-4 text-xs" },
                  Object.entries(selectedTerritory.units)
                    .filter(([_, count]) => count > 0)
                    .map(([type, count]) => e("li", { key: type, className: "animate-unit-place" }, e("span", { className: "unit-icon" }, UNITS[type].icon), " ", type, ": ", count))
                ),
                e("p", { className: "text-xs italic dark:text-gray-400" }, [selectedTerritory.isCapital ? "Capital" : "", selectedTerritory.victoryCity ? "Victory City" : "", selectedTerritory.factory ? "Factory" : ""].filter(Boolean).join(", "))
              )
            ),
            tutorialStep === 1 && e("div", { className: "tutorial-overlay mb-4" }, "Step 1: Click a territory on the map to select it."),
            e(
              "button",
              { onClick: handlePhaseAction, className: "modal-button bg-blue-600 text-white rounded w-full mt-4 hover:bg-blue-700 transition", "aria-label": `Complete ${currentPhase}` },
              "Complete Phase"
            ),
            mode === "computer" && aiHint && e("p", { className: "text-xs italic text-blue-600 dark:text-blue-400 mt-2" }, "AI Hint: ", aiHint),
            lastAction && e("button", { onClick: undoLastAction, className: "modal-button bg-yellow-600 text-white rounded w-full mt-2 hover:bg-yellow-700 transition" }, "Undo Last Action"),
            e(
              "div",
              { className: "mt-4 space-y-2" },
              e("label", { htmlFor: "game-mode-select", className: "text-sm font-medium dark:text-white" }, "Game Mode:"),
              e(
                "select",
                {
                  id: "game-mode-select",
                  value: mode,
                  onChange: e => setMode(e.target.value),
                  className: "border border-gray-300 dark:border-gray-600 rounded px-2 py-1 w-full text-sm dark:bg-gray-700 dark:text-white",
                  "aria-label": "Select game mode"
                },
                e("option", { value: "hotseat" }, "Hot Seat"),
                e("option", { value: "computer" }, "Vs. Computer"),
                e("option", { value: "online" }, "Online Multiplayer")
              ),
              mode === "online" && e(
                "div",
                { className: "flex gap-2" },
                e(
                  "input",
                  {
                    id: "session-id",
                    type: "text",
                    placeholder: "Session ID",
                    className: "border border-gray-300 dark:border-gray-600 rounded px-2 py-1 flex-1 text-sm dark:bg-gray-700 dark:text-white",
                    onChange: e => {
                      const id = e.target.value;
                      if (id) {
                        useGameStore.setState({ sessionId: id });
                        try {
                          const saved = localStorage.getItem(`a&a_${id}`);
                          if (saved) {
                            useGameStore.setState(JSON.parse(saved));
                            alert("Joined session!");
                          } else {
                            alert("New session created!");
                            saveGame();
                          }
                        } catch (e) {
                          console.error("Failed to load session:", e.message);
                          alert("Invalid session data!");
                        }
                      }
                    },
                    "aria-label": "Enter session ID"
                  }
                ),
                e("button", { className: "modal-button bg-blue-600 text-white rounded hover:bg-blue-700 transition", onClick: () => addChat("Joined the game!") }, "Join")
              )
            ),
            e("button", { onClick: resetGame, className: "modal-button bg-gray-500 text-white rounded w-full mt-4 hover:bg-gray-600 transition", "aria-label": "Reset Game" }, "Reset Game"),
            tutorialStep > 0 && e(
              "button",
              { onClick: disableTutorial, className: "modal-button bg-red-600 text-white rounded w-full mt-2 hover:bg-red-600 transition" },
              "Skip Tutorial"
            ),
            e(
              Modal,
              {
                isOpen: modal.isOpen,
                onClose: () => setModal({ isOpen: false, type: null, data: { target: null, units: {} } }),
                title: modal.type === "research" ? "Research & Development" : modal.type === "purchase" ? "Purchase Units" : modal.type === "combatMove" ? "Combat Move" : "Non-Combat Move",
                tutorialStep: tutorialStep > 1 && modal.type ? tutorialStep : null,
                tutorialText: tutorialText[modal.type]
              },
              modalContent[modal.type]
            )
          );
        });
        const Dashboard = React.memo(() => {
          const { ipcs, territories, currentNation, analytics, chatMessages, addChat } = useGameStore();
          const [chatInput, setChatInput] = React.useState("");
          const axisVictoryCities = territories.filter(t => t.victoryCity && (t.owner === "Germany" || t.owner === "Japan")).length;
          const alliesVictoryCities = territories.filter(t => t.victoryCity && (t.owner === "Soviet_Union" || t.owner === "United_Kingdom" || t.owner === "United_States")).length;
          return e(
            "div",
            { className: "bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-100 dark:border-gray-700 mt-6" },
            e("h3", { className: "text-lg font-bold mb-4 dark:text-white" }, "Dashboard"),
            e(
              "div",
              { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
              e(
                "div",
                null,
                e("p", { className: "text-sm dark:text-gray-300" }, e("span", { className: "font-medium" }, "Victory Cities: "), "Axis: ", axisVictoryCities, ", Allies: ", alliesVictoryCities),
                e("p", { className: "text-sm dark:text-gray-300" }, e("span", { className: "font-medium" }, "Battles Fought: "), analytics.battles),
                e("p", { className: "text-sm dark:text-gray-300" }, e("span", { className: "font-medium" }, "Actions Taken: "), analytics.actions)
              ),
              e(
                "div",
                null,
                e("h4", { className: "text-sm font-medium dark:text-white" }, "Chat"),
                e(
                  "div",
                  { className: "h-32 overflow-y-auto border border-gray-300 dark:border-gray-600 p-2 text-xs dark:bg-gray-700 dark:text-gray-300", "aria-live": "polite" },
                  chatMessages.map((msg, i) => e("p", { key: i }, e("strong", null, msg.sender, ":"), " ", msg.text, " ", e("span", { className: "text-gray-500" }, "(", msg.time, ")")))
                ),
                e(
                  "div",
                  { className: "flex mt-2" },
                  e(
                    "input",
                    {
                      type: "text",
                      value: chatInput,
                      onChange: e => setChatInput(e.target.value),
                      className: "border border-gray-300 dark:border-gray-600 rounded px-2 py-1 flex-1 text-sm dark:bg-gray-700 dark:text-white",
                      placeholder: "Type a message...",
                      "aria-label": "Enter chat message"
                    }
                  ),
                  e(
                    "button",
                    { onClick: () => { addChat(chatInput); setChatInput(""); }, className: "modal-button bg-blue-600 text-white rounded ml-2 hover:bg-blue-700" },
                    "Send"
                  )
                )
              )
            )
          );
        });
        const App = () => {
          const { isDarkMode, toggleDarkMode, tutorialStep, isLoading, setLoading } = useGameStore();
          React.useEffect(() => {
            document.body.classList.toggle("theme-dark", isDarkMode);
          }, [isDarkMode]);
          React.useEffect(() => {
            if (!isLoading) return;
            const timer = setTimeout(() => setLoading(false), 500);
            return () => clearTimeout(timer);
          }, [isLoading, setLoading]);
          if (isLoading) {
            return e("div", { className: "loading" }, e("div", { className: "spinner" }));
          }
          return e(
            ErrorBoundary,
            null,
            e(
              "div",
              { className: "container mx-auto px-4 py-6 max-w-7xl" },
              e(
                "header",
                { className: "bg-blue-950 text-white py-4 rounded-lg shadow-md mb-6" },
                e(
                  "div",
                  { className: "flex justify-between items-center px-4" },
                  e("h1", { className: "text-xl sm:text-2xl font-bold" }, "Axis & Allies: WWII 1942"),
                  e(
                    "button",
                    { onClick: toggleDarkMode, className: "modal-button bg-gray-700 text-white rounded hover:bg-gray-800", "aria-label": "Toggle Dark Mode" },
                    isDarkMode ? "‚òÄÔ∏è" : "üåô"
                  )
                )
              ),
              e(
                "div",
                { className: "grid grid-cols-1 lg:grid-cols-3 gap-4 sm:gap-6" },
                e(
                  "div",
                  { className: "lg:col-span-2 relative" },
                  tutorialStep === 1 && e("div", { className: "tutorial-overlay absolute z-10 p-4 m-4 max-w-xs" }, "Step 1: Click a territory on the map to select it."),
                  e(GameMap, null)
                ),
                e("div", { className: "lg:col-span-1" }, e
